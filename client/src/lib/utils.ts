import { FileType } from "./types";

export function ensureExtension(name: string, fileType: FileType): string {
  const ext = `.${fileType}`;
  if (!name.toLowerCase().endsWith(ext)) {
    return name + ext;
  }
  return name;
}

export function calculateTotalBytes(size: number, unit: string): number {
  switch (unit) {
    case "B": return size;
    case "KB": return size * 1024;
    case "MB": return size * 1024 * 1024;
    case "GB": return size * 1024 * 1024 * 1024;
    default: return size;
  }
}

export function formatBytes(bytes: number): string {
  if (bytes < 1024) return bytes + " B";
  const units = ["KB", "MB", "GB"];
  let i = -1;
  do {
    bytes /= 1024;
    i++;
  } while (bytes >= 1024 && i < units.length - 1);
  return bytes.toFixed(2) + " " + units[i];
}

export async function generateFile(totalBytes: number, fileType: FileType, filename: string) {
  
  if (fileType === FileType.TXT) {
    const buffer = new Uint8Array(totalBytes);
    buffer.fill(120); 
    
    const header = "Generated by ByteSmith\n";
    const headerEncoder = new TextEncoder().encode(header);
    
    if (totalBytes > headerEncoder.length) {
        buffer.set(headerEncoder, 0);
    }

    const blob = new Blob([buffer], { type: "text/plain" });
    triggerDownload(blob, filename);
    return;
  }

  const templatePath = `/templates/template.${fileType}`; 

  const response = await fetch(templatePath);
  
  if (!response.ok) {
    if (response.status === 404) {
        throw new Error(`Template untuk .${fileType} tidak ditemukan. Pastikan file 'template.${fileType}' ada di folder 'public/templates'.`);
    }
    throw new Error(`Gagal memuat template: ${response.statusText}`);
  }

  const contentType = response.headers.get("content-type");
  if (contentType && contentType.includes("text/html")) {
    throw new Error(`Template corrupt (terdeteksi HTML). Cek lokasi file template.`);
  }

  const baseBuffer = await response.arrayBuffer();
  const baseBytes = new Uint8Array(baseBuffer);

  if (totalBytes < baseBytes.length) {
    throw new Error(
      `Ukuran terlalu kecil! Template .${fileType} ini membutuhkan minimal ${formatBytes(baseBytes.length)}. Silakan naikkan ukuran file.`
    );
  }

  const remaining = totalBytes - baseBytes.length;

  const chunks: Uint8Array[] = [];
  chunks.push(baseBytes);

  if (remaining > 0) {
    const chunkSize = 1024 * 1024; 
    let created = 0;
    
    const zeroBuffer = new Uint8Array(chunkSize); 

    while (created < remaining) {
      const s = Math.min(chunkSize, remaining - created);
      if (s === chunkSize) {
        chunks.push(zeroBuffer);
      } else {
        chunks.push(new Uint8Array(s));
      }
      created += s;
    }
  }

  const blob = new Blob(chunks, { type: getMime(fileType) });
  triggerDownload(blob, filename);
}

function triggerDownload(blob: Blob, filename: string) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function getMime(ext: FileType) {
  switch (ext) {
    case "pdf": return "application/pdf";
    case "docx": return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    case "xlsx": return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    case "pptx": return "application/vnd.openxmlformats-officedocument.presentationml.presentation";
    default: return "text/plain";
  }
}

