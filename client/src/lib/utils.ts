import JSZip from "jszip";
import { FileType } from "./types";

export const MIN_FILE_SIZES: Record<FileType, number> = {
  [FileType.PPTX]: 100 * 1024,      
  [FileType.XLSX]: 15 * 1024,       
  [FileType.DOCX]: 15 * 1024,       
  [FileType.PDF]: 10 * 1024,        
  [FileType.TXT]: 5 * 1024,                
};

export function ensureExtension(name: string, fileType: FileType): string {
  const ext = `.${fileType}`;
  if (!name.toLowerCase().endsWith(ext)) {
    return name + ext;
  }
  return name;
}

export function calculateTotalBytes(size: number, unit: string): number {
  switch (unit) {
    case "B": return size;
    case "KB": return size * 1024;
    case "MB": return size * 1024 * 1024;
    case "GB": return size * 1024 * 1024 * 1024;
    default: return size;
  }
}

export function formatBytes(bytes: number): string {
  if (bytes < 1024) return bytes + " B";
  const units = ["KB", "MB", "GB"];
  let i = -1;
  do {
    bytes /= 1024;
    i++;
  } while (bytes >= 1024 && i < units.length - 1);
  return bytes.toFixed(2) + " " + units[i];
}

export async function generateFile(totalBytes: number, fileType: FileType, filename: string) {
  // Validasi minimal ukuran file
  const minSize = MIN_FILE_SIZES[fileType];
  if (totalBytes < minSize) {
    throw new Error(
      `Ukuran terlalu kecil! Minimal ukuran untuk file .${fileType} adalah ${formatBytes(minSize)}.`
    );
  }

  if (fileType === FileType.TXT) {
    const buffer = new Uint8Array(totalBytes);
    buffer.fill(120); 
    
    const header = "Generated by ByteSmith\n";
    const headerEncoder = new TextEncoder().encode(header);
    
    if (totalBytes > headerEncoder.length) {
        buffer.set(headerEncoder, 0);
    }

    const blob = new Blob([buffer], { type: "text/plain" });
    triggerDownload(blob, filename);
    return;
  }

  const templatePath = `/templates/template.${fileType}`; 

  const response = await fetch(templatePath);
  
  if (!response.ok) {
    if (response.status === 404) {
        throw new Error(`Template untuk .${fileType} tidak ditemukan. Pastikan file 'template.${fileType}' ada di folder 'public/templates'.`);
    }
    throw new Error(`Gagal memuat template: ${response.statusText}`);
  }

  const contentType = response.headers.get("content-type");
  if (contentType && contentType.includes("text/html")) {
    throw new Error(`Template corrupt (terdeteksi HTML). Cek lokasi file template.`);
  }

  const baseBuffer = await response.arrayBuffer();
  const baseBytes = new Uint8Array(baseBuffer);

  if (totalBytes < baseBytes.length) {
    throw new Error(
      `Ukuran terlalu kecil! Template .${fileType} ini membutuhkan minimal ${formatBytes(baseBytes.length)}. Silakan naikkan ukuran file.`
    );
  }

  // Untuk file Office (docx, xlsx, pptx), kita perlu memodifikasi struktur ZIP internal
  if (fileType === FileType.DOCX || fileType === FileType.XLSX || fileType === FileType.PPTX) {
    await generateOfficeFile(baseBytes, totalBytes, fileType, filename);
    return;
  }

  // Untuk file lainnya (PDF), lakukan padding seperti biasa
  const remaining = totalBytes - baseBytes.length;
  const chunks: Uint8Array[] = [];
  chunks.push(baseBytes);

  if (remaining > 0) {
    const chunkSize = 1024 * 1024; 
    let created = 0;
    const zeroBuffer = new Uint8Array(chunkSize); 

    while (created < remaining) {
      const s = Math.min(chunkSize, remaining - created);
      if (s === chunkSize) {
        chunks.push(zeroBuffer);
      } else {
        chunks.push(new Uint8Array(s));
      }
      created += s;
    }
  }

  const blob = new Blob(chunks, { type: getMime(fileType) });
  triggerDownload(blob, filename);
}

async function generateOfficeFile(baseBytes: Uint8Array, totalBytes: number, fileType: FileType, filename: string) {
  try {
    const zip = await JSZip.loadAsync(baseBytes);
    
    const targetSize = totalBytes;
    
    const testBlob = await zip.generateAsync({
      type: "blob",
      compression: "STORE"
    });
    
    const currentSize = testBlob.size;
    const remaining = targetSize - currentSize;
    
    if (remaining > 0) {
      let paddingSize = remaining;
      let iterationCount = 0;
      const maxIterations = 5;
      
      while (iterationCount < maxIterations) {
        if (zip.file("_bytesmith_padding.dat")) {
          zip.remove("_bytesmith_padding.dat");
        }
        
        const paddingData = new Uint8Array(Math.max(0, paddingSize));
        for (let i = 0; i < paddingData.length; i++) {
          paddingData[i] = i % 256;
        }
        
        zip.file("_bytesmith_padding.dat", paddingData, {
          compression: "STORE"
        });
        
        const newBlob = await zip.generateAsync({
          type: "blob",
          compression: "STORE"
        });
        
        const newSize = newBlob.size;
        const diff = targetSize - newSize;
        
        if (Math.abs(diff) <= 5) {
          triggerDownload(newBlob, filename);
          return;
        }
        
        paddingSize += diff;
        iterationCount++;
      }
      
      const finalBlob = await zip.generateAsync({
        type: "blob",
        compression: "STORE",
        mimeType: getMime(fileType)
      });
      
      triggerDownload(finalBlob, filename);
    } else {
      const blob = await zip.generateAsync({
        type: "blob",
        compression: "STORE",
        mimeType: getMime(fileType)
      });
      
      triggerDownload(blob, filename);
    }
    
  } catch (error) {
    console.error("Error generating Office file:", error);
    throw new Error(`Gagal generate file ${fileType}: ${error}`);
  }
}

function triggerDownload(blob: Blob, filename: string) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function getMime(ext: FileType) {
  switch (ext) {
    case "pdf": return "application/pdf";
    case "docx": return "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    case "xlsx": return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    case "pptx": return "application/vnd.openxmlformats-officedocument.presentationml.presentation";
    default: return "text/plain";
  }
}