import { FileType, FileUnit } from "./types";

export const calculateTotalBytes = (size: number, unit: FileUnit): number => {
  const multipliers: Record<FileUnit, number> = {
    [FileUnit.B]: 1,
    [FileUnit.KB]: 1024,
    [FileUnit.MB]: 1024 * 1024,
    [FileUnit.GB]: 1024 * 1024 * 1024,
  };
  return Math.floor(size * multipliers[unit]);
};

export 
const formatBytes = (bytes: number, decimals = 2): string => {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
};

export const getFileSignature = (type: FileType): Uint8Array => {
  const signatures: Record<FileType, number[]> = {
    [FileType.PDF]: [0x25, 0x50, 0x44, 0x46, 0x2D, 0x31, 0x2E, 0x35, 0x0A], // %PDF-1.5\n
    [FileType.DOCX]: [0x50, 0x4B, 0x03, 0x04], // ZIP header
    [FileType.XLSX]: [0x50, 0x4B, 0x03, 0x04], // ZIP header
    [FileType.PPTX]: [0x50, 0x4B, 0x03, 0x04], // ZIP header
    [FileType.JPG]: [0xFF, 0xD8, 0xFF, 0xE0], // JPEG
    [FileType.MP3]: [0xFF, 0xFB], // MPEG
    [FileType.TXT]: [], // No signature
  };
  return new Uint8Array(signatures[type]);
};

export const generateValidFile = (size: number, type: FileType): Uint8Array => {
  const fileData = new Uint8Array(size);
  
  switch (type) {
    case FileType.PDF: {
      // Minimal valid PDF structure
      const header = '%PDF-1.4\n';
      const content = '1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n2 0 obj\n<< /Type /Pages /Kids [] /Count 0 >>\nendobj\n';
      const xref = 'xref\n0 3\n0000000000 65535 f\n0000000009 00000 n\n0000000058 00000 n\n';
      const trailer = 'trailer\n<< /Size 3 /Root 1 0 R >>\nstartxref\n' + (header.length + content.length) + '\n%%EOF\n';
      
      const minimalPdf = header + content + xref + trailer;
      const pdfBytes = new TextEncoder().encode(minimalPdf);
      
      fileData.set(pdfBytes, 0);
      // Fill remaining with spaces for padding
      for (let i = pdfBytes.length; i < size; i++) {
        fileData[i] = 0x20; // space character
      }
      break;
    }
    
    case FileType.TXT: {
      // Text file with repeated content
      const text = 'This is a dummy test file generated by ByteSmith.\n';
      const textBytes = new TextEncoder().encode(text);
      for (let i = 0; i < size; i++) {
        fileData[i] = textBytes[i % textBytes.length];
      }
      break;
    }
    
    case FileType.JPG: {
      // Minimal valid JPEG structure
      // JPEG SOI (Start of Image)
      fileData[0] = 0xFF;
      fileData[1] = 0xD8;
      
      // JFIF APP0 marker
      fileData[2] = 0xFF;
      fileData[3] = 0xE0;
      fileData[4] = 0x00;
      fileData[5] = 0x10; // length
      fileData[6] = 0x4A; // 'J'
      fileData[7] = 0x46; // 'F'
      fileData[8] = 0x49; // 'I'
      fileData[9] = 0x46; // 'F'
      fileData[10] = 0x00; // null terminator
      fileData[11] = 0x01; // version
      fileData[12] = 0x01;
      fileData[13] = 0x00; // units
      fileData[14] = 0x00; // X density
      fileData[15] = 0x01;
      fileData[16] = 0x00; // Y density
      fileData[17] = 0x01;
      fileData[18] = 0x00; // thumbnail
      fileData[19] = 0x00;
      
      // Fill with padding
      for (let i = 20; i < size - 2; i++) {
        fileData[i] = 0xFF;
      }
      
      // JPEG EOI (End of Image)
      fileData[size - 2] = 0xFF;
      fileData[size - 1] = 0xD9;
      break;
    }
    
    case FileType.MP3: {
      // Minimal valid MP3 frame header
      fileData[0] = 0xFF; // Frame sync
      fileData[1] = 0xFB; // MPEG 1 Layer 3
      fileData[2] = 0x90; // Bitrate and sampling
      fileData[3] = 0x00; // Padding and mode
      
      // Fill rest with silence (0x00)
      for (let i = 4; i < size; i++) {
        fileData[i] = 0x00;
      }
      break;
    }
    
    case FileType.DOCX:
    case FileType.XLSX:
    case FileType.PPTX: {
      // Create a minimal ZIP archive structure
      // These formats are ZIP files with XML inside
      
      // Local file header for a minimal file
      const localHeader = new Uint8Array([
        0x50, 0x4B, 0x03, 0x04, // Local file header signature
        0x0A, 0x00, // Version needed to extract
        0x00, 0x00, // General purpose bit flag
        0x00, 0x00, // Compression method (stored)
        0x00, 0x00, // File last mod time
        0x00, 0x00, // File last mod date
        0x00, 0x00, 0x00, 0x00, // CRC-32
        0x00, 0x00, 0x00, 0x00, // Compressed size
        0x00, 0x00, 0x00, 0x00, // Uncompressed size
        0x08, 0x00, // File name length
        0x00, 0x00, // Extra field length
      ]);
      
      const fileName = new TextEncoder().encode('dummy.txt');
      
      // Central directory header
      const centralDir = new Uint8Array([
        0x50, 0x4B, 0x01, 0x02, // Central directory file header signature
        0x14, 0x00, // Version made by
        0x0A, 0x00, // Version needed to extract
        0x00, 0x00, // General purpose bit flag
        0x00, 0x00, // Compression method
        0x00, 0x00, // File last mod time
        0x00, 0x00, // File last mod date
        0x00, 0x00, 0x00, 0x00, // CRC-32
        0x00, 0x00, 0x00, 0x00, // Compressed size
        0x00, 0x00, 0x00, 0x00, // Uncompressed size
        0x08, 0x00, // File name length
        0x00, 0x00, // Extra field length
        0x00, 0x00, // File comment length
        0x00, 0x00, // Disk number start
        0x00, 0x00, // Internal file attributes
        0x00, 0x00, 0x00, 0x00, // External file attributes
        0x00, 0x00, 0x00, 0x00, // Relative offset of local header
      ]);
      
      // End of central directory record
      const endOfCentralDir = new Uint8Array([
        0x50, 0x4B, 0x05, 0x06, // End of central dir signature
        0x00, 0x00, // Number of this disk
        0x00, 0x00, // Disk where central directory starts
        0x01, 0x00, // Number of central directory records on this disk
        0x01, 0x00, // Total number of central directory records
        0x00, 0x00, 0x00, 0x00, // Size of central directory
        0x00, 0x00, 0x00, 0x00, // Offset of start of central directory
        0x00, 0x00, // Comment length
      ]);
      
      let offset = 0;
      
      // Write local file header
      fileData.set(localHeader, offset);
      offset += localHeader.length;
      fileData.set(fileName, offset);
      offset += fileName.length;
      
      // Calculate remaining space for padding
      const centralDirOffset = offset;
      const remainingBeforeCentral = size - offset - centralDir.length - fileName.length - endOfCentralDir.length;
      
      // Fill with padding spaces
      for (let i = 0; i < remainingBeforeCentral && offset < size; i++, offset++) {
        fileData[offset] = 0x20;
      }
      
      // Write central directory
      fileData.set(centralDir, offset);
      offset += centralDir.length;
      fileData.set(fileName, offset);
      offset += fileName.length;
      
      // Write end of central directory
      if (offset + endOfCentralDir.length <= size) {
        fileData.set(endOfCentralDir, offset);
      }
      break;
    }
  }
  
  return fileData;
};

// Generate and download file
export const generateFile = (size: number, type: FileType, filename: string) => {
  const fileData = generateValidFile(size, type);
  
  // Create blob and download
  const blob = new Blob([fileData], { type: 'application/octet-stream' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename || `dummy_${size}_bytes.${type}`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
};